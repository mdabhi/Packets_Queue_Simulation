#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define RAND_MAX 0x7FFF
#define MAXPACKETS 5000      //Max.packet length=5000 pkts
#define Avg_Arriv_rate 35   //Avg_packet_arrival rate(0.35<Rho<0.95)
#define Sys_Capacity 2000000
#define max(a,b) ((b)>(a)? (b):(a))

double RV1,RV2,Randomnum0to1,Sum=0,RVFunctionVal[1000],Variancesum=0,Arriv_Packet[7000],Observ_Time[7000],Depart_Time[7000];
double Tsys[7000],Ploss,Pidle,Avg_Pidle,Nsys,Expected_Mean,Expected_Variance,temp_array[21000],swap;
double Nobserv,Narriv,Avg_time_sys,Total_Avg_Pkt_Sys,Avg_Pkt_Observ,Buffer_K;
double Total_Avg_Pkt_Arriv=0,Avg_Pkt_Arriv=0,Total_Avg_Pidle=0;
double Total_Avg_time=0,MaxLimit;
unsigned char swap_type,Event_type[21000];

time_t t;
FILE *fp;
char Queue_Flag;
void Arrival_Event();void Departure_Event();void Observer_Event();

double Last_Arriv_Pkt,Last_Depart_Pkt,Last_Observ_Time;
double VarianceArray[1000],count_interarrival;
int RandomNum=0,a=0,Arriv_Cnt,Observ_Cnt,Depart_Cnt,Service_Cnt,lamda,length;
double Arrival_Time(int),Service_Time(),Service_Time_MG1(),Observe_RV_Time(int);
int h,i,j,k;
double tempvalue=0;
int l=0,m=0,n=0,x=0;
float Set_Rho;


void Simulate_M_M_1();   // main function simulator for M/M/1 queue
void Simulate_D_M_1();   // main function simulator for D/M/1 queue
void Simulate_M_G_1();   // main function simulator for M/G/1 queue
void Simulate_M_D_1();   // main function simulator for M/D/1 queue
void Simulate_M_D_2();   // main function simulator for M/D/2 queue

void Solution1();      // Solution for question1
double GenerateRandomVariable();   // Generates Inv.Exp.random variable
void CompareMeanNVariance();    // Calculates mean n variance by formula
void CalculateMeanNVariance();     // calculates mean n variance from experimental values

void Solution2_3();     // Solution for question2 n 3
void Get_Event_Times_MM1();      // Gets arrival time,service time and departure time in arrays for MM1
void Get_Event_Times_DM1();      // Gets arrival time,service time and departure time in arrays for DM1
void Get_Event_Times_MG1();      // Gets arrival time,service time and departure time in arrays for MG1

void Solution4();      // Solution for question4

void Solution7_8();    // Solution for question7 and 8

void Solution9();      // solution for question 9
void Get_Event_Times_MD1();     // Gets arrival time,service time and departure time in arrays for MD1
void Get_Event_Times_MD2();     // Gets arrival time,service time and departure time in arrays for MD2

void Initialize();      // Initialize all the variables
void Event_Scheduler();       // To schedule the events according to times
void MergeNSort_Arrays();      // Merges n sorts the times in ascending order

void Calculate_Parameters();       // Calculates the parameters from the values generated by simulator
void Compare_Parameters(float);      // Calculated parameter by theoretical formula and displays
void Display_Parameters();      // Displays the experimental/actual parameters


int main()
{
 //   srand((unsigned) time(&t));
    srand(0);

    printf("\nQueueing Simulation Project!");

    Solution1();
    Solution2_3();
    Solution4();
    Solution7_8();
    Solution9();
    return 0;
}

void Solution9()
{
    Simulate_M_D_1();
    Simulate_M_D_2();
}


void Simulate_M_D_1()
{
    printf("\n\n-----------M/D/1 Model-----------------");
    Set_Rho = 0.35;
    Queue_Flag = '1';

    fp=fopen("MD1Queue.txt","w");
    fputs("\n----------------M/D/1 Queue------------------",fp);
    fputs("\n----------------Rho=0.35 to 0.95 in step 0.05-------------",fp);

//    fclose(fp);
    fprintf(fp,"\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    printf("\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");


       while(Set_Rho < 1)
        {
            Initialize();

            Get_Event_Times_MD1();
            MergeNSort_Arrays();
            Event_Scheduler();

            Calculate_Parameters();
            Compare_Parameters(Set_Rho);
            Display_Parameters();

            Set_Rho= Set_Rho + 0.05;
       }


   fprintf(fp,"\n\n--------M/D/1 Simulation Completed----------");
   fclose(fp);
   printf("\n\n----------M/D/1 Simulation Completed----------");
}

void Simulate_M_D_2()
{
        printf("\n\n-----------M/D/2 Model-----------------");
    Set_Rho = 0.35;
    Queue_Flag = '2';

    fp=fopen("MD2Queue.txt","w");
    fputs("\n----------------M/D/2 Queue------------------",fp);
    fputs("\n----------------Rho=0.35 to 0.95 in step 0.05-------------",fp);

//    fclose(fp);
    fprintf(fp,"\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    printf("\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");


       while(Set_Rho < 1)
        {
            Initialize();

            Get_Event_Times_MD2();
            MergeNSort_Arrays();
            Event_Scheduler();

            Calculate_Parameters();
            Compare_Parameters(Set_Rho);
            Display_Parameters();

            Set_Rho= Set_Rho + 0.05;
       }


   fprintf(fp,"\n\n--------M/D/2 Simulation Completed----------");
   fclose(fp);
   printf("\n\n----------M/D/2 Simulation Completed----------");
}

void Solution7_8()
{
    printf("\n\n-----------M/D/1/K Model-----------------");
    Set_Rho = 0.4;
    Buffer_K = 10;
    Queue_Flag = 'K';

    fp=fopen("MD1KQueue.txt","w");
    fputs("\n----------------M/D/1/K Queue------------------",fp);
    fputs("\n----------------Rho=0.4 to 2 in step 0.1-------------",fp);
    fputs("\n----------------Rho=2 to 3 in step 0.2-------------",fp);
//    fclose(fp);
    fprintf(fp,"\n Buffer_K  Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]  Ploss");
    printf("\n Buffer_K  Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]  Ploss");


    while(Buffer_K<=100)
    {

        while(Set_Rho < 3.20)
        {
            Initialize();

            Get_Event_Times_MD1();
            MergeNSort_Arrays();
            Event_Scheduler();

            Calculate_Parameters();
            Compare_Parameters(Set_Rho);
            Display_Parameters();

            if(Set_Rho<2)
                Set_Rho= Set_Rho + 0.1;
            else
               Set_Rho= Set_Rho + 0.2;
       }

       if(Buffer_K == 10)
       {
         Set_Rho = 0.4;
         Buffer_K = 50;
  //       printf("----------------------------------------------------------");
       }
       else
       {
            if(Buffer_K==50)
           {
             Set_Rho = 0.4;
             Buffer_K = 100;
   //          printf("***********************************************************");
           }
           else
           {
             Set_Rho = 0.4;
             Buffer_K = 200;
   //          printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
           }
       }
   }
   fprintf(fp,"\n\n--------M/D/1/K Simulation Completed----------");
   fclose(fp);
   printf("\n\n----------M/D/1/K Simulation Completed----------");
}

void Solution1()
{
    printf("\nSolution 1:");

    fp=fopen("GenerateRV.txt","w");
    fprintf(fp,"\nSolution 1:");
    fputs("\n--------------Generates 1000 RV------------------",fp);

    CalculateMeanNVariance();      // call function which generates packets and find mean and variance

    printf("\n------------Solution1 Completed-------------");
    printf("\n");
    fprintf(fp,"\n----------Solution1 Completed-------------");

    fclose(fp);
}

void Solution2_3()
{
    Simulate_M_M_1();
    Simulate_D_M_1();
    Simulate_M_G_1();
}

void Solution4()
{
    //printf("\n\n-----------M/M/1 Model-----------------");
    printf("\n\n-----Solution_4---M/M/1 Queue------------------");
    printf("\n--------------------Rho=1.5-------------------");
//    myu = 0.1;
    Set_Rho = 1.5;
    Queue_Flag = '4';
    fp=fopen("Solution4.txt","w");
    fputs("\n-----Solution_4---M/M/1 Queue------------------",fp);
    fputs("\n--------------------Rho=1.5-------------------",fp);

    fprintf(fp,"\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    printf("\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");

    while(Set_Rho <= 1.5)
    {
        Initialize();

        Get_Event_Times_MM1();
        MergeNSort_Arrays();
        Event_Scheduler();

//        printf("\nTotal interarrival time=%lf",count_interarrival);
        Calculate_Parameters();

//        fp=fopen("Solution4.txt","a");
        Compare_Parameters(Set_Rho);
        Display_Parameters();
        Set_Rho= Set_Rho + 0.05;
   }
    fclose(fp);
    printf("\n\n------------Solution4 Completed-----------");
}




void Simulate_M_G_1()
{
    printf("\n\n-----------M/G/1 Model-----------------");
    Set_Rho = 0.35;
    Queue_Flag = 'G';
    fp=fopen("MG1Queue.txt","w");
    fputs("\n----------------M/G/1 Queue------------------",fp);
    fputs("\n----------------Rho=0.35 to 0.95-------------",fp);

    fprintf(fp,"\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    printf("\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    while(Set_Rho < 1.00)
    {
        Initialize();

        Get_Event_Times_MG1();
        MergeNSort_Arrays();
        Event_Scheduler();

        Calculate_Parameters();

        Compare_Parameters(Set_Rho);
        Display_Parameters();
        Set_Rho= Set_Rho + 0.05;

   }
    fclose(fp);
    printf("\n\n---M/G/1 Simulation Completed----------");
}

void Simulate_D_M_1()
{
    printf("\n\n-----------D/M/1 Model-----------------");
    Set_Rho = 0.35;
    Queue_Flag = 'D';
    fp=fopen("DM1Queue.txt","w");
    fputs("\n----------------D/M/1 Queue------------------",fp);
    fputs("\n----------------Rho=0.35 to 0.95-------------",fp);

    fprintf(fp,"\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    printf("\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");

    while(Set_Rho < 1.00)
    {
        Initialize();

        Get_Event_Times_DM1();
        MergeNSort_Arrays();
        Event_Scheduler();

        Calculate_Parameters();

        Compare_Parameters(Set_Rho);
        Display_Parameters();
        Set_Rho= Set_Rho + 0.05;
   }

   fclose(fp);
   printf("\n\n---D/M/1 Simulation Completed----------");
}

void Simulate_M_M_1()
{
    printf("\n\n-----------M/M/1 Model-----------------");
    Set_Rho = 0.35;
    Queue_Flag = 'M';
    fp=fopen("MM1Queue.txt","w");
    fputs("\n----------------M/M/1 Queue------------------",fp);
    fputs("\n----------------Rho=0.35 to 0.95-------------",fp);
//    fclose(fp);
    fprintf(fp,"\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    printf("\n Rho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");


    while(Set_Rho < 1.00)
    {
        Initialize();

        Get_Event_Times_MM1();
        MergeNSort_Arrays();
        Event_Scheduler();

        Calculate_Parameters();

        Compare_Parameters(Set_Rho);
        Display_Parameters();
        Set_Rho= Set_Rho + 0.05;
   }
   fclose(fp);
   printf("\n\n---M/M/1 Simulation Completed----------");
}

void Display_Parameters()
{
    Ploss  = Ploss/ Arriv_Cnt;
        //printf("\nRho  Expt_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
    if(Queue_Flag!= 'K')
    {
        fprintf(fp,"  %9.3lf  %8.4lf  %9.4lf  %8.4lf",Avg_Pidle,Avg_Pkt_Observ,Avg_Pkt_Arriv,Avg_time_sys);
        printf("  %9.3lf  %8.4lf  %9.4lf  %8.4lf",Avg_Pidle,Avg_Pkt_Observ,Avg_Pkt_Arriv,Avg_time_sys);
    }
    else
    {
        fprintf(fp,"  %9.3lf  %8.4lf  %9.4lf  %8.4lf  %5.4lf",Avg_Pidle,Avg_Pkt_Observ,Avg_Pkt_Arriv,Avg_time_sys,Ploss);
        printf("  %9.3lf  %8.4lf  %9.4lf  %8.4lf  %5.4lf",Avg_Pidle,Avg_Pkt_Observ,Avg_Pkt_Arriv,Avg_time_sys,Ploss);
    }
}


void Calculate_Parameters()
{
       if(Observ_Cnt!=0)
            Avg_Pkt_Observ = Nobserv/Observ_Cnt;//Average number of packets in the system seen by the observer


        if(Arriv_Cnt!=0)
            Avg_Pkt_Arriv = Narriv/Arriv_Cnt;//Average number of packets in the system seen by the arrival


        if(Observ_Cnt!=0)
            Avg_Pidle = Pidle/Observ_Cnt;//Average Pidle


        Avg_time_sys = Avg_Pkt_Observ/ lamda; //Avg.time spent by packet in system
}

void Get_Event_Times_MG1()
{
        while(count_interarrival<20000)
        {
            if(i!=0)
            Arriv_Packet[i] = Arrival_Time(lamda)+ Arriv_Packet[i-1];

            count_interarrival = count_interarrival + Arriv_Packet[i];


            tempvalue = Service_Time_MG1()/Sys_Capacity;
            if(i!=0)
              Depart_Time[i] = tempvalue +(max(Arriv_Packet[i],Depart_Time[i-1]));


             if(i!=0)
               Observ_Time[i] = Observe_RV_Time(length)+ Observ_Time[i-1];

            // j++;
             i++;
             a++;

        }
}

double Service_Time_MG1()
{
    double InvFuncRV;
Step2:
    RV1 = (double)rand()/(double)RAND_MAX;

    if(RV1 > 0)
    {
        if(RV1<=0.2)
        {
            InvFuncRV=16000;
            return InvFuncRV;
        }
        else
        {
            InvFuncRV=21000;
            return InvFuncRV;
        }
    }
    else
    {
        goto Step2;
    }

}

void Get_Event_Times_DM1()
{
        while(count_interarrival<20000)     //// Check for summation of inter arrival <20000 secs.
        {
            if(i!=0)
//            Arriv_Packet[i] = Arrival_Time(lamda)+ Arriv_Packet[i-1];
                Arriv_Packet[i] = (double)1/(lamda)+ Arriv_Packet[i-1];   //// D/M/1 model, Arrival is Deterministic,constant

            count_interarrival = count_interarrival + Arriv_Packet[i];


            tempvalue = Service_Time()/Sys_Capacity;
            if(i==0)
            {
                   Depart_Time[i]= 0;
            }
            else
               Depart_Time[i] = tempvalue +(max(Arriv_Packet[i],Depart_Time[i-1]));


             if(i!=0)
               Observ_Time[i] = Observe_RV_Time(length)+ Observ_Time[i-1];

            // j++;
             i++;
             a++;
 //            printf("\tA=%d",a);

        }
}

void Get_Event_Times_MD2()
{
//    int L=20000;
       j=0;
       fclose(fp);
       fp = fopen("Gettime.txt","a");

        while(count_interarrival<20000)     //
        {
            if(i!=0)
            Arriv_Packet[i] = Arrival_Time(lamda)+ Arriv_Packet[i-1];

            count_interarrival = count_interarrival + Arriv_Packet[i];

            fprintf(fp,"\nArrive Array[%d]= %lf, A",i,Arriv_Packet[i]);

              if(i!=0)
               Observ_Time[i] = Observe_RV_Time(length)+ Observ_Time[i-1];

            fprintf(fp,"\nObserve Array[%d]= %lf, O",i,Observ_Time[i]);
            // j++;
             i++;
             a++;
//             printf("\tA=%d",a);

        }

        while(j<= i)
        {

            if(Queue_Flag == 'K')
               tempvalue = 0.01;   //// for MD1 queue, service time = L/C
            else if(Queue_Flag == '1')
                tempvalue = 0.005;
            else if(Queue_Flag == '2')
                tempvalue = 0.01;

            fprintf(fp,"\ntempvalue= %lf, T",tempvalue);

            if(j==0)
            {
                Depart_Time[0] = 0;
                j++;
            }
            else if(j==1)
            {
                   Depart_Time[1]= tempvalue + Arriv_Packet[1];
                   j++;
            }
            else if (j==2)
            {
                Depart_Time[2]= tempvalue + Arriv_Packet[2];
                j++;
            }
            else
            {
                Depart_Time[j] = tempvalue +(max(Arriv_Packet[j],Depart_Time[j-2]));
                Depart_Time[j+1] = tempvalue +(max(Arriv_Packet[j+1],Depart_Time[j-1]));
                j= j+2;
            }

            fprintf(fp,"\nDepart Array[%d]= %lf, D",i,Depart_Time[i]);
        }

        switch(Queue_Flag)
        {
            case 'K':
                fp=fopen("MD1KQueue.txt","a");
            break;
            case '1':
                fp=fopen("MD1Queue.txt","a");
            break;
            case '2':
                fp=fopen("MD2Queue.txt","a");
            break;

        }

}

void Get_Event_Times_MD1()
{
//    int L=20000;

       fclose(fp);
       fp = fopen("Gettime.txt","a");

        while(count_interarrival<20000)     //
        {
            if(i!=0)
            Arriv_Packet[i] = Arrival_Time(lamda)+ Arriv_Packet[i-1];

            count_interarrival = count_interarrival + Arriv_Packet[i];

            fprintf(fp,"\nArrive Array[%d]= %lf, A",i,Arriv_Packet[i]);

            if(Queue_Flag == 'K')
               tempvalue = 0.01;   //// for MD1 queue, service time = L/C
            else if(Queue_Flag == '1')
                tempvalue = 0.005;
            else if(Queue_Flag == '2')
                tempvalue = 0.01;

            fprintf(fp,"\ntempvalue= %lf, T",tempvalue);

            if(i==0)
            {
                   Depart_Time[i]= 0;
            }
            else
               Depart_Time[i] = tempvalue +(max(Arriv_Packet[i],Depart_Time[i-1]));

            fprintf(fp,"\nDepart Array[%d]= %lf, D",i,Depart_Time[i]);

             if(i!=0)
               Observ_Time[i] = Observe_RV_Time(length)+ Observ_Time[i-1];

            fprintf(fp,"\nObserve Array[%d]= %lf, O",i,Observ_Time[i]);
            // j++;
             i++;
             a++;
//             printf("\tA=%d",a);

        }

        switch(Queue_Flag)
        {
            case 'K':
                fp=fopen("MD1KQueue.txt","a");
            break;
            case '1':
                fp=fopen("MD1Queue.txt","a");
            break;
            case '2':
                fp=fopen("MD2Queue.txt","a");
            break;

        }

}

void Get_Event_Times_MM1()
{
        while(count_interarrival<20000)     ////iteration no.,h=2 is just for debugging,will increase the no.for longer time
        {
            if(i!=0)
            Arriv_Packet[i] = Arrival_Time(lamda)+ Arriv_Packet[i-1];

            count_interarrival = count_interarrival + Arriv_Packet[i];


            tempvalue = Service_Time()/Sys_Capacity;
            if(i==0)
            {
                   Depart_Time[i]= 0;
            }
            else
               Depart_Time[i] = tempvalue +(max(Arriv_Packet[i],Depart_Time[i-1]));


             if(i!=0)
               Observ_Time[i] = Observe_RV_Time(length)+ Observ_Time[i-1];
/*
            fp=fopen("test1.txt","a");
            fprintf(fp,"ArrivalPacket=%lf ",Arriv_Packet[i]);
            fprintf(fp,"DeparturePacket=%lf ",Depart_Time[i]);
            fprintf(fp,"ObserverPacket=%lf\n",Observ_Time[i]);
            fclose(fp);
*/
            // j++;
             i++;
             a++;
 //            printf("\tA=%d",a);

        }
}

void MergeNSort_Arrays()
{

  //      fprintf(fp,"Array size=%i         Total size =%i \n",a,3*a);

           for(l=0;l<3*a;l++)
           {
               if(l<i)
               {
                    temp_array[l]=Arriv_Packet[l];
                    Event_type[l]= 'A';

 //                   l++;
               }
               else if(l<2*a)
               {
                    temp_array[l]=Depart_Time[m];
                    Event_type[l]= 'D';
                    m++;
//                    l++;
               }
               else
               {    if(l<3*a)
                    temp_array[l]=Observ_Time[n];
                    Event_type[l]= 'O';
//                    l++;
                    n++;
               }
 //              fprintf(fp,"M\n");
 //              fprintf(fp,"array[%i]=%1f type=%c\n",l,temp_array[l],Event_type[l]);
           }

            for(k=0;k<(3*a-1);k++)
            {
                 for(l=0;l<3*a-k-1;l++)
                 {
                     if(temp_array[l]>temp_array[l+1])
                     {
                           swap=temp_array[l];
                           swap_type=Event_type[l];

                           temp_array[l]=temp_array[l+1];
                           Event_type[l]=Event_type[l+1];

                           temp_array[l+1]=swap;
                           Event_type[l+1]=swap_type;

                     }

                 }
            }
}

void Event_Scheduler()
{
   //     fprintf(fp,"--------------Sorted Array------------\n");

        for(x=0;x<3*a;x++)
        {
//                fprintf(fp,"-------Sorted Array------------\n");
   //        fprintf(fp,"array[%i]=%1f type=%c\n",x,temp_array[x],Event_type[x]);
           if(Event_type[x]=='A')
           {
               Arrival_Event();
    //           fprintf(fp,"A\n");
           }
           else if(Event_type[x]=='D')
           {
               Departure_Event();

            }
           else if(Event_type[x]=='O')
           {
              Observer_Event();
   //           fprintf(fp,"O\n");
           }
        }
   //     fclose(fp);
}

void Initialize()
{
   a=0;
   j=0;
   i=0;
   k=0;
   l=0;
   m=0;
   n=0;
   i=0;

   tempvalue=0;
   Pidle=0;
   Ploss = 0;
   Arriv_Cnt=0;
   Depart_Cnt=0;
   Observ_Cnt=0;
   Avg_Pidle=0;
   Nsys=0;
   Narriv=0;
   Nobserv=0;
   count_interarrival=0;  ///Adding arrival time and stop the loop when total is 10000
   lamda = Set_Rho*100;/// lamda=0.35*100=35
   length  = Set_Rho*100; /// length=35

   Last_Arriv_Pkt = 0;
   Last_Observ_Time = 0.0;
   Last_Arriv_Pkt = 0;


    Depart_Time[0] = 0;
    Arriv_Packet[0]= Last_Arriv_Pkt;
    Observ_Time[0] = Last_Observ_Time;
}

double Observe_RV_Time(int length)
{
    double InvFuncRV;
Step3:
	RV1=(double)rand()/(double)(RAND_MAX);
	if(RV1!=0)
	{
		InvFuncRV = -log(1-RV1)/length;
        return InvFuncRV;
	}
	else
	{
		goto Step3;
	}
}

double Arrival_Time(int lamda)
{
    double InvFuncRV;
Step1:
    RV1 = (double)rand()/(double)RAND_MAX;
    if(RV1!=0)
    {
        InvFuncRV = -(log(1-RV1))/lamda;
        return(InvFuncRV);
    }
    else
    {
        goto Step1;
    }

}

double Service_Time()
{
    double InvFuncRV;
Step2:
    RV1 = (double)rand()/(double)RAND_MAX;
    if(RV1!=0)
    {
        InvFuncRV = -(20000)*log(1-RV1);          /// Multiplied by E[L]=20000
        return(InvFuncRV);
    }
    else
    {
        goto Step2;
    }

}

void Arrival_Event()
{
     Arriv_Cnt++;
       if(Queue_Flag == 'K')
       {
           if((Arriv_Cnt - Depart_Cnt)< Buffer_K)
           {
              Nsys++;
 //             printf("\nDifference=%d",Arriv_Cnt - Depart_Cnt);
 //             printf("\nN");
           }
           else
           {
               Ploss++;
 //              printf("\nLLLLLLLLLLLLL");
           }
     //             fprintf(fp,"D\n");
       }
       else
       {
           Nsys++;
 //          printf("\nO");
       }

//     Tsys[k]=Arriv_Packet[k];
     Narriv = Narriv+Nsys;
}

void Departure_Event()
{
     if(Nsys>0)
     {
         Nsys--;
     }
    Depart_Cnt++;
 //   Tsys[k]=Depart_Time[k];
}

void Observer_Event()
{
    Observ_Cnt++;
    Nobserv = Nobserv+Nsys;
    if(Nsys==0)
    {
         Pidle++;
    }
}

void Compare_Parameters(float Rho)
{
    float Expected_Pidle;
    double SoujonTime=0,Expect_Nsys;

    Expected_Pidle = 1.00 - Rho;
    Expect_Nsys = (double)(Rho/Expected_Pidle);
    SoujonTime = (double)Expect_Nsys/(lamda);
//    SoujonTime  =


//printf("\nRho  Exp_Pidle  Exp_E[N]  Exp_E[T]  Act_Pidle  Act_E[N]  Act_Ea[N]  Act_E[T]");
         switch(Queue_Flag)
        {
            case 'M':
                printf("\n%3.2f  %9.2f  %8.4lf  %8.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                fprintf(fp,"\n%3.2f  %9.2f  %8.4lf  %8.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                break;
            case 'D':
                printf("\n%3.2f  %9.2f  %8.4lf  %8.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                fprintf(fp,"\n%3.2f  %9.2f  %8.4lf  %8.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
               break;
            case 'G':
                printf("\n%3.2f  %9.2f  %8.4lf  %8.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                fprintf(fp,"\n%3.2f  %9.2f  %8.4lf  %8.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                break;
            case 'K':
                Expected_Pidle =0 ;
                Expect_Nsys = 0;
                SoujonTime = 0;

                //  printf("\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                  printf("\n%4lf  %3.2f         --        --        --",Buffer_K,Rho);
    //            fp=fopen("MM1Queue.txt","a");
               // fprintf(fp,"\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
               fprintf(fp,"\n%4lf  %3.2f         --        --        --",Buffer_K,Rho);
                break;
            case '1':
              //  Expected_Pidle =0 ;
                Expect_Nsys = 0;
                SoujonTime = 0;

                //  printf("\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                  printf("\n%3.2f  %9.2f        --        --",Rho,Expected_Pidle);
    //            fp=fopen("MM1Queue.txt","a");
               // fprintf(fp,"\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
               fprintf(fp,"\n%3.2f  %9.2f        --        --",Rho,Expected_Pidle);
                break;
            case '2':
            //    Expected_Pidle =0 ;
                Expect_Nsys = 0;
                SoujonTime = 0;

                //  printf("\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                  printf("\n%3.2f  %9.2f        --        --",Rho,Expected_Pidle);
    //            fp=fopen("MM1Queue.txt","a");
               // fprintf(fp,"\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
               fprintf(fp,"\n%3.2f  %9.2f        --        --",Rho,Expected_Pidle);
                break;

            case '4':
                Expected_Pidle =0 ;
                Expect_Nsys = 0;
                SoujonTime = 0;

                //  printf("\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
                  printf("\n%3.2f         --        --        --",Rho);
    //            fp=fopen("MM1Queue.txt","a");
               // fprintf(fp,"\n%3.2f  %12.2f  %11.4lf  %11.4lf",Rho,Expected_Pidle,Expect_Nsys,SoujonTime);
               fprintf(fp,"\n%3.2f         --        --        --",Rho);
               break;
            default:
                break;
        }

//    fp=fopen("MM1Queue.txt","a");

//    fclose(fp);

}

void CalculateMeanNVariance()
{
    lamda = 10;         /*myu=1/10 given in problem*/
    a=0,Sum=0;

    while(a<1000)
    {
        RVFunctionVal[a] = GenerateRandomVariable();
//        printf("\tInverse exp.func=%f",RVFunctionVal[a]);
        Sum = Sum + RVFunctionVal[a];
        a++;
    }

    Sum = Sum /1000;

    CompareMeanNVariance();

    printf("\n Actual Mean is %lf",Sum);
    fprintf(fp,"\n Actual Mean is %lf",Sum);

    a = 0;
    Variancesum = 0;
    while(a<1000)
    {
        VarianceArray[a] = pow(Sum - RVFunctionVal[a],2);
        Variancesum = Variancesum + VarianceArray[a];
        a++;
    }

    Variancesum = Variancesum/ 1000;
    printf("\n Actual Variance is %lf",Variancesum);
    printf("\n Total no.of RVs=%d",a);

    fprintf(fp,"\n Actual Variance is %lf",Variancesum);
    fprintf(fp,"\n Total no.of RVs=%d",a);

}

double GenerateRandomVariable()
{
    double InvFuncRV;

Step1:
    RV1 = (double)rand()/(double)RAND_MAX;
    if(RV1!=0)
    {
            InvFuncRV = - (double)(log(1-RV1))/lamda;
            printf("\nRandom Variable=%5lf Inverse Fun=%5lf",RV1,InvFuncRV);
            fprintf(fp,"\nRandom Variable=%5lf Inverse Fun=%5lf",RV1,InvFuncRV);
            return(InvFuncRV);
    }
    else
    {
        goto Step1;
    }

}
void CompareMeanNVariance()
{

   Expected_Mean = (double)1/lamda;
   Expected_Variance = (double) 1/ pow(lamda,2);
   printf("\n Expected Mean is %f",Expected_Mean);
   printf("\n Expected Variance is %f",Expected_Variance);

   fprintf(fp,"\n Expected Mean is %f",Expected_Mean);
   fprintf(fp,"\n Expected Variance is %f",Expected_Variance);
}
